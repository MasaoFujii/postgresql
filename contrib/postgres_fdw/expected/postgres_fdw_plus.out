-- ===================================================================
-- global settings
-- ===================================================================
-- Don't display CONTEXT fields in messages from the server,
-- to make the tests stable.
\set SHOW_CONTEXT never
-- ===================================================================
-- create database users
-- ===================================================================
CREATE ROLE regress_pgfdw_local_super1 SUPERUSER;
CREATE ROLE regress_pgfdw_local_super2 SUPERUSER;
CREATE ROLE regress_pgfdw_remote_super1 SUPERUSER LOGIN;
CREATE ROLE regress_pgfdw_remote_super2 SUPERUSER LOGIN;
SET ROLE regress_pgfdw_local_super1;
-- ===================================================================
-- create FDW objects
-- ===================================================================
-- postgres_fdw was already installed in postgres_fdw.sql
DO $d$
    BEGIN
        EXECUTE $$CREATE SERVER pgfdw_plus_loopback1
            FOREIGN DATA WRAPPER postgres_fdw
            OPTIONS (dbname '$$||current_database()||$$',
                     port '$$||current_setting('port')||$$',
                     application_name 'pgfdw_plus_loopback1'
            )$$;
        EXECUTE $$CREATE SERVER pgfdw_plus_loopback2
            FOREIGN DATA WRAPPER postgres_fdw
            OPTIONS (dbname '$$||current_database()||$$',
                     port '$$||current_setting('port')||$$',
                     application_name 'pgfdw_plus_loopback2'
            )$$;
    END;
$d$;
CREATE USER MAPPING FOR PUBLIC SERVER pgfdw_plus_loopback1
  OPTIONS (user 'regress_pgfdw_remote_super1');
CREATE USER MAPPING FOR CURRENT_USER SERVER pgfdw_plus_loopback2
  OPTIONS (user 'regress_pgfdw_remote_super2');
-- create dummy foreign data wrapper, server and user mapping
-- to test the error cases
CREATE FOREIGN DATA WRAPPER pgfdw_plus_dummy;
CREATE SERVER pgfdw_plus_dummy_server FOREIGN DATA WRAPPER pgfdw_plus_dummy;
CREATE USER MAPPING FOR PUBLIC SERVER pgfdw_plus_dummy_server;
-- drop previously-created server that may have unexpected effect
-- on this test, to make the test stable
SET client_min_messages TO 'error';
DROP SERVER IF EXISTS testserver1 CASCADE;
RESET client_min_messages;
-- ===================================================================
-- create objects used by local transaction or through FDW
-- pgfdw_plus_loopback1 and pgfdw_plus_loopback2 servers
-- ===================================================================
CREATE SCHEMA regress_pgfdw_plus;
SET search_path TO regress_pgfdw_plus, "$user", public;
CREATE TABLE t0 (c1 int PRIMARY KEY, c2 int);
CREATE TABLE t1 (c1 int PRIMARY KEY, c2 int);
CREATE TABLE t2 (c1 int PRIMARY KEY, c2 int);
-- Disable autovacuum for these tables to avoid unexpected effects of that
ALTER TABLE t0 SET (autovacuum_enabled = 'false');
ALTER TABLE t1 SET (autovacuum_enabled = 'false');
ALTER TABLE t2 SET (autovacuum_enabled = 'false');
INSERT INTO t0 SELECT id, id FROM generate_series(1, 10) id;
INSERT INTO t1 SELECT id, id FROM generate_series(11, 20) id;
INSERT INTO t2 SELECT id, id FROM generate_series(21, 30) id;
ANALYZE t0;
ANALYZE t1;
ANALYZE t2;
-- ===================================================================
-- create foreign tables
-- ===================================================================
CREATE FOREIGN TABLE ft1 (c1 int, c2 int) SERVER pgfdw_plus_loopback1
    OPTIONS (schema_name 'regress_pgfdw_plus', table_name 't1');
CREATE FOREIGN TABLE ft2 (c1 int, c2 int) SERVER pgfdw_plus_loopback2
    OPTIONS (schema_name 'regress_pgfdw_plus', table_name 't2');
-- ===================================================================
-- test two phase commit
-- ===================================================================
SET debug_discard_caches = 0;
SET postgres_fdw.two_phase_commit TO true;
-- All three transactions are committed via two phase commit
-- protocol because they are write transactions.
BEGIN;
INSERT INTO t0 VALUES (100, 100);
INSERT INTO ft1 VALUES (100, 100);
INSERT INTO ft2 VALUES (100, 100);
COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
       split_part       
------------------------
 COMMIT PREPARED 'pgfdw
 COMMIT PREPARED 'pgfdw
(2 rows)

SELECT * FROM pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)

SELECT count(*) FROM t0 WHERE c1 = 100;
 count 
-------
     1
(1 row)

SELECT count(*) FROM ft1 WHERE c1 = 100;
 count 
-------
     1
(1 row)

SELECT count(*) FROM ft2 WHERE c1 = 100;
 count 
-------
     1
(1 row)

-- All three transactions are committed via two phase commit protocol
-- because two (local and foreign) of them are write transactions.
BEGIN;
INSERT INTO t0 VALUES (200, 200);
INSERT INTO ft1 VALUES (200, 200);
SELECT count(*) FROM ft2;
 count 
-------
    11
(1 row)

COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
       split_part       
------------------------
 COMMIT PREPARED 'pgfdw
 COMMIT PREPARED 'pgfdw
(2 rows)

SELECT * FROM pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)

SELECT count(*) FROM t0 WHERE c1 = 200;
 count 
-------
     1
(1 row)

SELECT count(*) FROM ft1 WHERE c1 = 200;
 count 
-------
     1
(1 row)

-- All three transactions are committed via two phase commit protocol
-- because two (two foreign) of them are write transactions.
BEGIN;
SELECT count(*) FROM t0;
 count 
-------
    12
(1 row)

INSERT INTO ft1 VALUES (300, 300);
INSERT INTO ft2 VALUES (300, 300);
COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
       split_part       
------------------------
 COMMIT PREPARED 'pgfdw
 COMMIT PREPARED 'pgfdw
(2 rows)

SELECT * FROM pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)

SELECT count(*) FROM ft1 WHERE c1 = 300;
 count 
-------
     1
(1 row)

SELECT count(*) FROM ft2 WHERE c1 = 300;
 count 
-------
     1
(1 row)

-- All three transactions are committed without using two phase commit
-- protocol because only local transaction is write one.
BEGIN;
INSERT INTO t0 VALUES (400, 400);
SELECT count(*) FROM ft1;
 count 
-------
    13
(1 row)

SELECT count(*) FROM ft2;
 count 
-------
    12
(1 row)

COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
     split_part     
--------------------
 COMMIT TRANSACTION
 COMMIT TRANSACTION
(2 rows)

SELECT count(*) FROM t0 WHERE c1 = 400;
 count 
-------
     1
(1 row)

-- All three transactions are committed without using two phase commit
-- protocol because only one foreign transaction is write one.
BEGIN;
SELECT count(*) FROM t0;
 count 
-------
    13
(1 row)

INSERT INTO ft1 VALUES (500, 500);
SELECT count(*) FROM ft2;
 count 
-------
    12
(1 row)

COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
     split_part     
--------------------
 COMMIT TRANSACTION
 COMMIT TRANSACTION
(2 rows)

SELECT count(*) FROM ft1 WHERE c1 = 500;
 count 
-------
     1
(1 row)

-- All three transactions are committed without using two phase commit
-- protocol because there are no write transactions.
BEGIN;
SELECT count(*) FROM t0;
 count 
-------
    13
(1 row)

SELECT count(*) FROM ft1;
 count 
-------
    14
(1 row)

SELECT count(*) FROM ft2;
 count 
-------
    12
(1 row)

COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
     split_part     
--------------------
 COMMIT TRANSACTION
 COMMIT TRANSACTION
(2 rows)

-- When local transaction is rollbacked, foreign transactions are
-- rollbacked without using two phase commit protocol.
BEGIN;
INSERT INTO t0 VALUES (600, 600);
INSERT INTO ft1 VALUES (600, 600);
INSERT INTO ft2 VALUES (600, 600);
ROLLBACK;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
   split_part   
----------------
 DEALLOCATE ALL
 DEALLOCATE ALL
(2 rows)

SELECT count(*) FROM t0 WHERE c1 = 600;
 count 
-------
     0
(1 row)

SELECT count(*) FROM ft1 WHERE c1 = 600;
 count 
-------
     0
(1 row)

SELECT count(*) FROM ft2 WHERE c1 = 600;
 count 
-------
     0
(1 row)

-- All three transactions are rollbacked because PREPARE TRANSACTION
-- fails on one of foreign server.
BEGIN;
INSERT INTO t0 VALUES (700, 700);
INSERT INTO ft1 VALUES (700, 700);
INSERT INTO ft2 VALUES (700, 700);
SELECT pg_terminate_backend(pid, 10000) FROM pg_stat_activity
       WHERE application_name = 'pgfdw_plus_loopback2';
 pg_terminate_backend 
----------------------
 t
(1 row)

COMMIT;
ERROR:  FATAL:  terminating connection due to administrator command
server closed the connection unexpectedly
	This probably means the server terminated abnormally
	before or while processing the request.
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
   split_part   
----------------
 DEALLOCATE ALL
(1 row)

SELECT * FROM pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)

SELECT count(*) FROM t0 WHERE c1 = 700;
 count 
-------
     0
(1 row)

SELECT count(*) FROM ft1 WHERE c1 = 700;
 count 
-------
     0
(1 row)

SELECT count(*) FROM ft2 WHERE c1 = 700;
 count 
-------
     0
(1 row)

RESET postgres_fdw.two_phase_commit;
RESET debug_discard_caches;
-- ===================================================================
-- test error cases of pg_foreign_prepared_xacts and
-- pg_resolve_foreign_prepared_xacts
-- ===================================================================
-- should fail because specified server doesn't exist
SELECT * FROM pg_foreign_prepared_xacts('nonexistent');
ERROR:  user mapping for server "nonexistent" and user "regress_pgfdw_local_super1" not found
SELECT * FROM pg_resolve_foreign_prepared_xacts('nonexistent');
ERROR:  user mapping for server "nonexistent" and user "regress_pgfdw_local_super1" not found
-- should fail because there is no user mapping for specified server and
-- current user
SET ROLE regress_pgfdw_local_super2;
SELECT * FROM pg_foreign_prepared_xacts('pgfdw_plus_loopback2');
ERROR:  user mapping for server "pgfdw_plus_loopback2" and user "regress_pgfdw_local_super2" not found
SELECT * FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_loopback2');
ERROR:  user mapping for server "pgfdw_plus_loopback2" and user "regress_pgfdw_local_super2" not found
SET ROLE regress_pgfdw_local_super1;
-- should fail because foreign data wrapper of specified server
-- is not postgres_fdw
SELECT * FROM pg_foreign_prepared_xacts('pgfdw_plus_dummy_server');
ERROR:  foreign data wrapper of specified server must be "postgres_fdw"
SELECT * FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_dummy_server');
ERROR:  foreign data wrapper of specified server must be "postgres_fdw"
-- should fail because dblink has not been installed yet
SELECT * FROM pg_foreign_prepared_xacts('pgfdw_plus_loopback1');
ERROR:  extension "dblink" must be installed
SELECT * FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_loopback1');
ERROR:  extension "dblink" must be installed
-- ===================================================================
-- test functions to resolve foreign prepared transactions
-- ===================================================================
CREATE EXTENSION dblink;
-- These functions should return 0 rows because there are no foreign
-- prepared transactions
SELECT count(*) FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_loopback1');
 count 
-------
     0
(1 row)

SELECT count(*) FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_loopback2');
 count 
-------
     0
(1 row)

SELECT count(*) FROM pg_resolve_foreign_prepared_xacts_all();
 count 
-------
     0
(1 row)

-- xact_commits should be emptied because there are no foreign
-- prepared transactions
SELECT count(*) FROM pgfdw_plus.xact_commits;
 count 
-------
     3
(1 row)

SELECT count(*) FROM pg_vacuum_xact_commits();
 count 
-------
     3
(1 row)

SELECT count(*) FROM pgfdw_plus.xact_commits;
 count 
-------
     0
(1 row)

-- Set two_phase_commit to 'prepare' to create foreign prepared transactions.
-- Note that more than two foreign prepared transactions cannot be created
-- because max_prepared_xacts is set to 2 in regression test.
SET postgres_fdw.two_phase_commit TO 'prepare';
BEGIN;
INSERT INTO ft1 VALUES (101, 101);
INSERT INTO ft2 VALUES (101, 101);
COMMIT;
SELECT count(*) FROM pg_foreign_prepared_xacts('pgfdw_plus_loopback1');
 count 
-------
     1
(1 row)

SELECT count(*) FROM pg_foreign_prepared_xacts('pgfdw_plus_loopback2');
 count 
-------
     1
(1 row)

SELECT count(*) FROM pgfdw_plus.xact_commits;
 count 
-------
     1
(1 row)

-- Resolve foreign prepared transactions on only one of servers
SELECT count(*) FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_loopback1');
 count 
-------
     1
(1 row)

SELECT count(*) FROM pg_foreign_prepared_xacts('pgfdw_plus_loopback1');
 count 
-------
     0
(1 row)

SELECT count(*) FROM pg_foreign_prepared_xacts('pgfdw_plus_loopback2');
 count 
-------
     1
(1 row)

-- xact_commits still should have one row referencing to foreign prepared
-- transactions on another server
SELECT count(*) FROM pg_vacuum_xact_commits();
 count 
-------
     0
(1 row)

SELECT count(*) FROM pgfdw_plus.xact_commits;
 count 
-------
     1
(1 row)

-- All foreign prepared transactions are resolved and xact_commits
-- should be empty
SELECT count(*) FROM pg_resolve_foreign_prepared_xacts_all();
 count 
-------
     1
(1 row)

SELECT count(*) FROM pg_foreign_prepared_xacts('pgfdw_plus_loopback1');
 count 
-------
     0
(1 row)

SELECT count(*) FROM pg_foreign_prepared_xacts('pgfdw_plus_loopback2');
 count 
-------
     0
(1 row)

SELECT count(*) FROM pg_vacuum_xact_commits();
 count 
-------
     1
(1 row)

SELECT count(*) FROM pgfdw_plus.xact_commits;
 count 
-------
     0
(1 row)

RESET postgres_fdw.two_phase_commit;
-- ===================================================================
-- reset global settings
-- ===================================================================
\unset SHOW_CONTEXT
