-- ===================================================================
-- global settings
-- ===================================================================
-- Don't display CONTEXT fields in messages from the server,
-- to make the tests stable.
\set SHOW_CONTEXT never
-- ===================================================================
-- create database users
-- ===================================================================
CREATE ROLE regress_pgfdw_plus_super1 SUPERUSER;
CREATE ROLE regress_pgfdw_plus_super2 SUPERUSER;
SET ROLE regress_pgfdw_plus_super1;
-- ===================================================================
-- create FDW objects
-- ===================================================================
-- postgres_fdw was already installed in postgres_fdw.sql
DO $d$
    BEGIN
        EXECUTE $$CREATE SERVER pgfdw_plus_loopback1
            FOREIGN DATA WRAPPER postgres_fdw
            OPTIONS (dbname '$$||current_database()||$$',
                     port '$$||current_setting('port')||$$',
                     application_name 'pgfdw_plus_loopback1'
            )$$;
        EXECUTE $$CREATE SERVER pgfdw_plus_loopback2
            FOREIGN DATA WRAPPER postgres_fdw
            OPTIONS (dbname '$$||current_database()||$$',
                     port '$$||current_setting('port')||$$',
                     application_name 'pgfdw_plus_loopback2'
            )$$;
    END;
$d$;
CREATE USER MAPPING FOR PUBLIC SERVER pgfdw_plus_loopback1;
CREATE USER MAPPING FOR CURRENT_USER SERVER pgfdw_plus_loopback2;
-- ===================================================================
-- create objects used by local transaction or through FDW
-- pgfdw_plus_loopback1 and pgfdw_plus_loopback2 servers
-- ===================================================================
CREATE SCHEMA regress_pgfdw_plus;
SET search_path TO regress_pgfdw_plus, "$user", public;
CREATE TABLE t0 (c1 int PRIMARY KEY, c2 int);
CREATE TABLE t1 (c1 int PRIMARY KEY, c2 int);
CREATE TABLE t2 (c1 int PRIMARY KEY, c2 int);
-- Disable autovacuum for these tables to avoid unexpected effects of that
ALTER TABLE t0 SET (autovacuum_enabled = 'false');
ALTER TABLE t1 SET (autovacuum_enabled = 'false');
ALTER TABLE t2 SET (autovacuum_enabled = 'false');
INSERT INTO t0 SELECT id, id FROM generate_series(1, 10) id;
INSERT INTO t1 SELECT id, id FROM generate_series(11, 20) id;
INSERT INTO t2 SELECT id, id FROM generate_series(21, 30) id;
ANALYZE t0;
ANALYZE t1;
ANALYZE t2;
-- ===================================================================
-- create foreign tables
-- ===================================================================
CREATE FOREIGN TABLE ft1 (c1 int, c2 int) SERVER pgfdw_plus_loopback1
    OPTIONS (schema_name 'regress_pgfdw_plus', table_name 't1');
CREATE FOREIGN TABLE ft2 (c1 int, c2 int) SERVER pgfdw_plus_loopback2
    OPTIONS (schema_name 'regress_pgfdw_plus', table_name 't2');
-- ===================================================================
-- test two phase commit
-- ===================================================================
SET debug_discard_caches = 0;
SET postgres_fdw.two_phase_commit TO true;
-- All three transactions are committed via two phase commit
-- protocol because they are write transactions.
BEGIN;
INSERT INTO t0 VALUES (100, 100);
INSERT INTO ft1 VALUES (100, 100);
INSERT INTO ft2 VALUES (100, 100);
COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
       split_part       
------------------------
 COMMIT PREPARED 'pgfdw
 COMMIT PREPARED 'pgfdw
(2 rows)

SELECT * FROM pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)

SELECT count(*) FROM t0 WHERE c1 = 100;
 count 
-------
     1
(1 row)

SELECT count(*) FROM ft1 WHERE c1 = 100;
 count 
-------
     1
(1 row)

SELECT count(*) FROM ft2 WHERE c1 = 100;
 count 
-------
     1
(1 row)

-- All three transactions are committed via two phase commit protocol
-- because two (local and foreign) of them are write transactions.
BEGIN;
INSERT INTO t0 VALUES (200, 200);
INSERT INTO ft1 VALUES (200, 200);
SELECT count(*) FROM ft2;
 count 
-------
    11
(1 row)

COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
       split_part       
------------------------
 COMMIT PREPARED 'pgfdw
 COMMIT PREPARED 'pgfdw
(2 rows)

SELECT * FROM pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)

SELECT count(*) FROM t0 WHERE c1 = 200;
 count 
-------
     1
(1 row)

SELECT count(*) FROM ft1 WHERE c1 = 200;
 count 
-------
     1
(1 row)

-- All three transactions are committed via two phase commit protocol
-- because two (two foreign) of them are write transactions.
BEGIN;
SELECT count(*) FROM t0;
 count 
-------
    12
(1 row)

INSERT INTO ft1 VALUES (300, 300);
INSERT INTO ft2 VALUES (300, 300);
COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
       split_part       
------------------------
 COMMIT PREPARED 'pgfdw
 COMMIT PREPARED 'pgfdw
(2 rows)

SELECT * FROM pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)

SELECT count(*) FROM ft1 WHERE c1 = 300;
 count 
-------
     1
(1 row)

SELECT count(*) FROM ft2 WHERE c1 = 300;
 count 
-------
     1
(1 row)

-- All three transactions are committed without using two phase commit
-- protocol because only local transaction is write one.
BEGIN;
INSERT INTO t0 VALUES (400, 400);
SELECT count(*) FROM ft1;
 count 
-------
    13
(1 row)

SELECT count(*) FROM ft2;
 count 
-------
    12
(1 row)

COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
     split_part     
--------------------
 COMMIT TRANSACTION
 COMMIT TRANSACTION
(2 rows)

SELECT count(*) FROM t0 WHERE c1 = 400;
 count 
-------
     1
(1 row)

-- All three transactions are committed without using two phase commit
-- protocol because only one foreign transaction is write one.
BEGIN;
SELECT count(*) FROM t0;
 count 
-------
    13
(1 row)

INSERT INTO ft1 VALUES (500, 500);
SELECT count(*) FROM ft2;
 count 
-------
    12
(1 row)

COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
     split_part     
--------------------
 COMMIT TRANSACTION
 COMMIT TRANSACTION
(2 rows)

SELECT count(*) FROM ft1 WHERE c1 = 500;
 count 
-------
     1
(1 row)

-- All three transactions are committed without using two phase commit
-- protocol because there are no write transactions.
BEGIN;
SELECT count(*) FROM t0;
 count 
-------
    13
(1 row)

SELECT count(*) FROM ft1;
 count 
-------
    14
(1 row)

SELECT count(*) FROM ft2;
 count 
-------
    12
(1 row)

COMMIT;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
     split_part     
--------------------
 COMMIT TRANSACTION
 COMMIT TRANSACTION
(2 rows)

-- When local transaction is rollbacked, foreign transactions are
-- rollbacked without using two phase commit protocol.
BEGIN;
INSERT INTO t0 VALUES (600, 600);
INSERT INTO ft1 VALUES (600, 600);
INSERT INTO ft2 VALUES (600, 600);
ROLLBACK;
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
   split_part   
----------------
 DEALLOCATE ALL
 DEALLOCATE ALL
(2 rows)

SELECT count(*) FROM t0 WHERE c1 = 600;
 count 
-------
     0
(1 row)

SELECT count(*) FROM ft1 WHERE c1 = 600;
 count 
-------
     0
(1 row)

SELECT count(*) FROM ft2 WHERE c1 = 600;
 count 
-------
     0
(1 row)

-- All three transactions are rollbacked because PREPARE TRANSACTION
-- fails on one of foreign server.
BEGIN;
INSERT INTO t0 VALUES (700, 700);
INSERT INTO ft1 VALUES (700, 700);
INSERT INTO ft2 VALUES (700, 700);
SELECT pg_terminate_backend(pid, 10000) FROM pg_stat_activity
       WHERE application_name = 'pgfdw_plus_loopback2';
 pg_terminate_backend 
----------------------
 t
(1 row)

COMMIT;
ERROR:  FATAL:  terminating connection due to administrator command
server closed the connection unexpectedly
	This probably means the server terminated abnormally
	before or while processing the request.
SELECT split_part(query, '_', 1) FROM pg_stat_activity
    WHERE application_name LIKE 'pgfdw_plus_loopback%';
   split_part   
----------------
 DEALLOCATE ALL
(1 row)

SELECT * FROM pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)

SELECT count(*) FROM t0 WHERE c1 = 700;
 count 
-------
     0
(1 row)

SELECT count(*) FROM ft1 WHERE c1 = 700;
 count 
-------
     0
(1 row)

SELECT count(*) FROM ft2 WHERE c1 = 700;
 count 
-------
     0
(1 row)

RESET postgres_fdw.two_phase_commit;
RESET debug_discard_caches;
-- ===================================================================
-- test pg_resolve_foreign_prepared_xacts
-- ===================================================================
CREATE EXTENSION dblink;
SELECT * FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_loopback1');
 status | server | transaction | gid | prepared | owner | database 
--------+--------+-------------+-----+----------+-------+----------
(0 rows)

SELECT * FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_loopback2');
 status | server | transaction | gid | prepared | owner | database 
--------+--------+-------------+-----+----------+-------+----------
(0 rows)

-- This test should fail because the specified server doesn't exist.
SELECT * FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_nonexistent');
ERROR:  user mapping for server "pgfdw_plus_nonexistent" and user "regress_pgfdw_plus_super1" not found
SET ROLE regress_pgfdw_plus_super2;
SELECT * FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_loopback1');
 status | server | transaction | gid | prepared | owner | database 
--------+--------+-------------+-----+----------+-------+----------
(0 rows)

-- This test should fail because no user mapping for the specified server
-- and regress_pgfdw_plus_super2 exists.
SELECT * FROM pg_resolve_foreign_prepared_xacts('pgfdw_plus_loopback2');
ERROR:  user mapping for server "pgfdw_plus_loopback2" and user "regress_pgfdw_plus_super2" not found
SET ROLE regress_pgfdw_plus_super1;
-- ===================================================================
-- reset global settings
-- ===================================================================
\unset SHOW_CONTEXT
